# Check if a number is Palindrome or Not

# Problem Statement: Given an integer N, return true if it is a palindrome else return false.

A palindrome is a number that reads the same backward as forward. For example, 121, 1331, and 4554 are palindromes because they remain the same when their digits are reversed.

Examples
Example 1:
```js
Input:N = 4554
Output:Palindrome Number
Explanation: The reverse of 4554 is 4554 and therefore it is palindrome number
                                        
Example 2:
Input:N = 7789          
Output: Not Palindrome
Explanation: The reverse of number 7789 is 9877 and therefore it is not palindrome
```
   
# Approach
Algorithm / Intuition
To check if a number is a palindrome, we can use the algorithm created in Extract Digits as now we extract the digits of the number to create a reversed number.

We then compare the reversed number with the original number. If they are equal, the original number is a palindrome. If they are not equal the original number is not a palindrome.

Algorithm
Initialise an integer revNum to 0. This variable will store the reverse of the number.
Make a duplicate of the original number and store it in an integer dup for later comparison.
Run a while loop with the condition n>0 to reverse the number and at each iteration
Get the last digit of n by using the modulus operator % with 10 and store it in a temporary variable ld.
Update the revNum by multiplying it by 10 and adding the last digit ld.
Update n by integer division with 10 effectively removing the last digit.
After the loop, check if the original number dup is equal to the reversed number revNum.
If they are equal, return true indicating the number is a palindrome.
If they are not equal, return false indicating that the number is not a palindrome.

# code
```js
import.java.util.*;
public class Solution {
    // Function to reverse digits of a number
    public int reverseNumber(int n) {
        // Variable to store reversed number
        int revNum = 0;

        // Loop until all digits are processed
        while (n > 0) {
            // Get the last digit
            int lastDigit = n % 10;

            // Append it to the reversed number
            revNum = revNum * 10 + lastDigit;

            // Remove the last digit from n
            n = n / 10;
        }

        // Return the reversed number
        return revNum;
    }
}

// Driver code
class Main {
    public static void main(String[] args) {
        Solution obj = new Solution();
        int num = 12345;
        System.out.println(obj.reverseNumber(num));  // Output: 54321
    }
}

```

# Complexity Analysis

Time Complexity: O(log10N + 1), as in the worst case when N is a multiple of 10 the number of digits in N is log10 N + 1. In the while loop we divide N by 10 until it becomes 0 which takes log10N iterations. In each iteration of the while loop we perform constant time operations like modulus and division and pushing elements into the vector.

Space Complexity: O(1), as only a constant amount of additional memory for the reversed number regardless of size of the input number.
